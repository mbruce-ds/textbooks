\chapter{Getting Started}\,
\section{Insertion sort}

\qn{1.} Using Figure 2.2 as a model, illustrate the operation of \verb|INSERTION-SORT| on the array $A = \langle 31, 41, 59, 26, 41, 58\rangle$.

\sol First pass: key set to 41. \verb|A[1] = 31 < 41|, so the while loop breaks, and the second element stays put.

Second pass: key set to 59. Same steps as above.

Third pass: Key set to 26. \verb|A[3] = 59 > 26|, so set \verb|A[4] = 59|. \verb|A[2] =| \verb|41 > 26|, so set \verb|A[3] = 41|. \verb|A[1] = 31 > 26|, so set \verb|A[2] = 31|. Loop breaks, set \verb|A[1] = 26|.

Fourth pass: Key set to 41. \verb|A[4] = 59 > 41|, so set \verb|A[5] = 59|. \verb|A[3] =| \verb|41|, so the while loop breaks. Set \verb|[4] = 41|.

Final pass: Key set to 58. \verb|A[5] = 59 > 58|, so set \verb|A[6] = 59|. \verb|A[4] =| \verb|41 < 58|, so the while loop breaks. Set \verb|[5] = 58|. The final sorted array is $\langle 26, 31, 41, 41, 58, 59\rangle$.\qed

\qn{2.} Rewrite the \verb|INSERTION-SORT| procedure to sort into nonincreasing instead of nondecreasing order.

\sol Rewrite the algorithm as follows.
\begin{Verbatim}[frame=single,numbers=left,samepage=true,label=REVERSE-INSERTION-SORT(A)]
for j = 2 to A.length
    key = A[j]
    // Insert A[j] into the sorted sequence A[1..j-1].
    i = j - 1
    while i > 0 and A[i] < key // The only change
        A[i + 1] = A[i]
        i = i - 1
    A[i + 1] = key
\end{Verbatim}

The implementation of this can be found in \newline\verb|code/<language>/chapter02/reverse_insertion_sort/|.\qed

\qn{3.} Consider the \textbf{searching problem}:

\textbf{Input:} A sequence of $n$ numbers $A = \langle a_1, a_2, \dots, a_n \rangle$ and a value $v$.

\textbf{Output:} An index $i$ such that $v = A[i]$ or the special value \verb|NIL| if $v$ does not appear in $A$.

Write pseudocode for \textbf{linear search}, which scans through the sequence, looking for $v$. Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties.

\sol The algorithm is as follows.

\begin{Verbatim}[frame=single,numbers=left,samepage=true,label={LINEAR-SEARCH(A,v)}]
for i = 1 to A.length
    if A[i] == v
        return i
return NIL
\end{Verbatim}

The loop invariant can be stated as follows: At the start of each iteration of the for loop, the subarray $A[1..i-1]$ does not contain the value $v$. We will show this invariant has the three necessary properties to prove the correctness of the algorithm. Prior to the first loop, the subarray $A[1..0]$ is an empty array, which clearly does not contain $v$. Suppose the invariant is true after loop $i$, that is, $A[1..i]$ does not contain $v$. Then on loop $i+1$, if $A[i+1] == v$, the algorithm will exit, returning $i+1$. If the algorithm does not exit, the loop iteration completes and thus $A[1..i+1]$ does not contain $v$. When the loop terminates without the algorithm prematurely returning, that means that $v$ is not contained in $A[1..n]$, and thus \verb|NIL| is returned. So the loop invariant fulfills the necessary properties to prove correctness of the algorithm. \qed

\qn{4.} Consider the problem of adding two $n$-bit binary integers, stored in two $n$-element arrays $A$ and $B$. The sum of the two integers should be stored in binary form in an $(n+1)$-element array $C$. State the problem formally and write pseudocode for adding the two integers.

\sol Define the problems as follows:

\textbf{Input:} Two sequences $A, B$ representing binary numbers, where the sequences are length $n$ and contain only 0 or 1. The endianness of $A,B$ should be defined, as it affects the algorithm to solve it. We will assume big-endian.

\textbf{Output:} A length $n+1$ sequence representing the binary sum $A+B$.

Write the algorithm solving the problem as follows:

\begin{Verbatim}[frame=single,numbers=left,samepage=true,label={ADD(A,B)}]
carry = 0
for i = A.length to 1
    sum = A[i] + B[i] + carry // Binary addition
    if sum % 10 == 1 // Sum either 01 or 11
        S[i+1] = 1
    if sum >= 10 // Sum either 10 or 11
        carry = 1
    else
        carry = 0
S[0] = carry
return S
\end{Verbatim}
\qed


\section{Analyzing algorithms}
\qn{1.} Express the function $n^3 / 1000 - 100n^2 - 100n + 3$ in terms of $\Theta$-notation.

\sol Considering the informal definition of $\Theta$-notation in this chapter, we simply observe that  the $n^3 / 1000$ term is the leading term and dominates for large $n$, and drop the coefficient, expressing the function as $\Theta(n^3)$.\qed

\qn{2.} Consider sorting $n$ numbers stored in array $A$ by first finding the smallest element of $A$ and exchanging it with the element in $A[1]$. Then find the second smallest element of $A$, and exchange it with $A[2]$. Continue in this manner for the first $n-1$ elements of $A$. Write pseudocode for this algorithm, which is known as \textbf{selection sort}. What loop invariant does this algorithm maintain? Why does it need to run for only the first $n-1$ elements, rather than for all $n$ elements? Give the best-case and worst-case running times of selection sort in $\Theta$-notation.

\sol
\begin{Verbatim}[frame=single,numbers=left,samepage=true,label={SELECTION-SORT(A)}]
for j = 1 to A.length - 1
    current_min = stored_val = A[j]
    stored_index = j
    for i = j + 1 to A.length
        if A[i] < current_min
            current_min = A[i]
            stored_index = i
    A[j] = current_min
    A[stored_index] = stored_val
\end{Verbatim}

See \verb|code/<language>/chapter02/selection_sort/| for implementation of this algorithm.

The loop invariant that the outer loop maintains is that the subarray $A[1..j]$ is sorted. Informally, this holds because the minimum element is selected to the first index, the second smallest element is selected to the second index, and so forth through the first $j$ elements. The loop only needs to run for the first $n-1$ elements because after $n-1$ iterations, the largest element is necessarily in the final index, as the $n-i$th largest elements are already all fixed to the $i$th indices. The best case runtime is $\Theta(n^2)$, since even with an input list that is already sorted, there is no way to early stop either for loop, as all elements need to be checked to confirm each candidate element is the current minimum. The worst case is equivalently $\Theta(n^2)$, as the same checks as in the best case are still performed, but the current minimum and stored index are updated on each increment of the $i$ index (in $\Theta$ notation, this only adds a linear term which is already accounted for by the nested loop).
\qed

\qn{3.} Consider linear search again (see Exercise 2.1-3). How many elements of the input sequence need to be checked on the average, assuming that the element being searched for is equally likely to be any element in the array? How about in the worst case? What are the average-case and worst-case running times of linear search in $\Theta$ notation? Justify your answers.

\sol \qed

\qn{4.} How can we modify almost any algorithm to have a good best-case running time?

\sol \qed